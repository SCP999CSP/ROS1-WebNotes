# 2.1.2 Topic Communication Basic Operations

**Requirement:**

> Write a publish-subscribe implementation where the publisher publishes text messages at 10Hz (10 times per second), and the subscriber subscribes to the messages and prints the message content.

**Analysis:**

In the model implementation, ROS Master does not need to be implemented, and the connection establishment is already encapsulated. The key points to focus on are three:

1. Publisher
2. Subscriber
3. Data (here we use plain text)

**Process:**

1. Write the publisher implementation;
2. Write the subscriber implementation;
3. Add execute permissions to the Python files;
4. Edit the configuration file;
5. Compile and execute.

#### 1. Publisher

```python
#! /usr/bin/env python
"""
    Requirement: Implement basic topic communication, where one party publishes data and another receives data.
         Key implementation points:
         1. Sender
         2. Receiver
         3. Data (here, plain text)

         PS: Both need to set the same topic


    Message Publisher:
        Loop to publish messages: HelloWorld with a suffix number.

    Implementation process:
        1. Import packages
        2. Initialize ROS node: naming (unique)
        3. Instantiate the publisher object
        4. Organize the data to be published and write the logic to publish the data.


"""
#1. Import packages
import rospy
from std_msgs.msg import String

if __name__ == "__main__":
    #2. Initialize ROS node: naming (unique)
    rospy.init_node("talker_p")
    #3. Instantiate the publisher object
    pub = rospy.Publisher("chatter",String,queue_size=10)
    #4. Organize the data to be published and write the logic to publish the data
    msg = String()  # Create msg object
    msg_front = "hello 你好"
    count = 0  # Counter
    # Set loop frequency
    rate = rospy.Rate(1)
    while not rospy.is_shutdown():

        # Concatenate string
        msg.data = msg_front + str(count)

        pub.publish(msg)
        rate.sleep()
        rospy.loginfo("Written data:%s",msg.data)
        count += 1
```

#### 2. Subscriber

```python
#! /usr/bin/env python
"""
    Requirement: Implement basic topic communication, where one party publishes data and another receives data.
         Key implementation points:
         1. Sender
         2. Receiver
         3. Data (here, plain text)


    Message Subscriber:
        Subscribe to the topic and print the received messages.

    Implementation process:
        1. Import packages
        2. Initialize ROS node: naming (unique)
        3. Instantiate the subscriber object
        4. Process the subscribed messages (callback function)
        5. Set up loop to call the callback function



"""
#1. Import packages
import rospy
from std_msgs.msg import String

def doMsg(msg):
    rospy.loginfo("I heard:%s",msg.data)

if __name__ == "__main__":
    #2. Initialize ROS node: naming (unique)
    rospy.init_node("listener_p")
    #3. Instantiate the subscriber object
    sub = rospy.Subscriber("chatter",String,doMsg,queue_size=10)
    #4. Process the subscribed messages (callback function)
    #5. Set up loop to call the callback function
    rospy.spin()
```

#### 3. Add Execute Permissions

Navigate to scripts in the terminal and execute: `chmod +x *.py`

#### 4. Configure CMakeLists.txt

```cmake
catkin_install_python(PROGRAMS
  scripts/talker_p.py
  scripts/listener_p.py
  DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
)
```

#### 5. Execution

1. Start roscore;
2. Start the publisher node;
3. Start the subscriber node.

The running result is similar to demonstration case 1 in the introduction section.

------

PS: You can use rqt_graph to view node relationships.