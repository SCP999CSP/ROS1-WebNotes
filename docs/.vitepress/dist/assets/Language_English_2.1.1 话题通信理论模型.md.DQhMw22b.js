import{_ as a,c as r,o as t,af as l,aA as i}from"./chunks/framework.BYZYS_oT.js";const d=JSON.parse('{"title":"2.1.1 话题通信理论模型","description":"","frontmatter":{},"headers":[],"relativePath":"Language/English/2.1.1 话题通信理论模型.md","filePath":"Language/English/2.1.1 话题通信理论模型.md"}'),s={name:"Language/English/2.1.1 话题通信理论模型.md"};function n(_,e,k,h,o,p){return t(),r("div",null,[...e[0]||(e[0]=[l('<h1 id="_2-1-1-话题通信理论模型" tabindex="-1">2.1.1 话题通信理论模型 <a class="header-anchor" href="#_2-1-1-话题通信理论模型" aria-label="Permalink to “2.1.1 话题通信理论模型”">​</a></h1><p>话题通信实现模型是比较复杂的，该模型如下图所示,该模型中涉及到三个角色:</p><ul><li>ROS Master (管理者)</li><li>Talker (发布者)</li><li>Listener (订阅者)</li></ul><p>ROS Master 负责保管 Talker 和 Listener 注册的信息，并匹配话题相同的 Talker 与 Listener，帮助 Talker 与 Listener 建立连接，连接建立后，Talker 可以发布消息，且发布的消息会被 Listener 订阅。</p><p><img src="'+i+'" alt="img">整个流程由以下步骤实现:</p><h4 id="_0-talker注册" tabindex="-1">0.Talker注册 <a class="header-anchor" href="#_0-talker注册" aria-label="Permalink to “0.Talker注册”">​</a></h4><p>Talker启动后，会通过RPC在 ROS Master 中注册自身信息，其中包含所发布消息的话题名称。ROS Master 会将节点的注册信息加入到注册表中。</p><h4 id="_1-listener注册" tabindex="-1">1.Listener注册 <a class="header-anchor" href="#_1-listener注册" aria-label="Permalink to “1.Listener注册”">​</a></h4><p>Listener启动后，也会通过RPC在 ROS Master 中注册自身信息，包含需要订阅消息的话题名。ROS Master 会将节点的注册信息加入到注册表中。</p><h4 id="_2-ros-master实现信息匹配" tabindex="-1">2.ROS Master实现信息匹配 <a class="header-anchor" href="#_2-ros-master实现信息匹配" aria-label="Permalink to “2.ROS Master实现信息匹配”">​</a></h4><p>ROS Master 会根据注册表中的信息匹配Talker 和 Listener，并通过 RPC 向 Listener 发送 Talker 的 RPC 地址信息。</p><h4 id="_3-listener向talker发送请求" tabindex="-1">3.Listener向Talker发送请求 <a class="header-anchor" href="#_3-listener向talker发送请求" aria-label="Permalink to “3.Listener向Talker发送请求”">​</a></h4><p>Listener 根据接收到的 RPC 地址，通过 RPC 向 Talker 发送连接请求，传输订阅的话题名称、消息类型以及通信协议(TCP/UDP)。</p><h4 id="_4-talker确认请求" tabindex="-1">4.Talker确认请求 <a class="header-anchor" href="#_4-talker确认请求" aria-label="Permalink to “4.Talker确认请求”">​</a></h4><p>Talker 接收到 Listener 的请求后，也是通过 RPC 向 Listener 确认连接信息，并发送自身的 TCP 地址信息。</p><h4 id="_5-listener与talker件里连接" tabindex="-1">5.Listener与Talker件里连接 <a class="header-anchor" href="#_5-listener与talker件里连接" aria-label="Permalink to “5.Listener与Talker件里连接”">​</a></h4><p>Listener 根据步骤4 返回的消息使用 TCP 与 Talker 建立网络连接。</p><h4 id="_6-talker向listener发送消息" tabindex="-1">6.Talker向Listener发送消息 <a class="header-anchor" href="#_6-talker向listener发送消息" aria-label="Permalink to “6.Talker向Listener发送消息”">​</a></h4><p>连接建立后，Talker 开始向 Listener 发布消息。</p><blockquote><p>注意1:上述实现流程中，前五步使用的 RPC协议，最后两步使用的是 TCP 协议</p><p>注意2: Talker 与 Listener 的启动无先后顺序要求</p><p>注意3: Talker 与 Listener 都可以有多个</p><p>注意4: Talker 与 Listener 连接建立后，不再需要 ROS Master。也即，即便关闭ROS Master，Talker 与 Listern 照常通信。</p></blockquote>',20)])])}const c=a(s,[["render",n]]);export{d as __pageData,c as default};
