import{_ as a,c as r,o as i,af as l,aC as t}from"./chunks/framework.CZgp8l78.js";const m=JSON.parse('{"title":"2.3.1 参数服务器理论模型","description":"","frontmatter":{},"headers":[],"relativePath":"2.3.1 参数服务器理论模型.md","filePath":"2.3.1 参数服务器理论模型.md"}'),s={name:"2.3.1 参数服务器理论模型.md"};function n(_,e,o,p,d,c){return i(),r("div",null,[...e[0]||(e[0]=[l('<h1 id="_2-3-1-参数服务器理论模型" tabindex="-1">2.3.1 参数服务器理论模型 <a class="header-anchor" href="#_2-3-1-参数服务器理论模型" aria-label="Permalink to “2.3.1 参数服务器理论模型”">​</a></h1><p>参数服务器实现是最为简单的，该模型如下图所示,该模型中涉及到三个角色:</p><ul><li>ROS Master (管理者)</li><li>Talker (参数设置者)</li><li>Listener (参数调用者)</li></ul><p>ROS Master 作为一个公共容器保存参数，Talker 可以向容器中设置参数，Listener 可以获取参数。</p><p><img src="'+t+'" alt="img"></p><p>整个流程由以下步骤实现:</p><h4 id="_1-talker-设置参数" tabindex="-1">1.Talker 设置参数 <a class="header-anchor" href="#_1-talker-设置参数" aria-label="Permalink to “1.Talker 设置参数”">​</a></h4><p>Talker 通过 RPC 向参数服务器发送参数(包括参数名与参数值)，ROS Master 将参数保存到参数列表中。</p><h4 id="_2-listener-获取参数" tabindex="-1">2.Listener 获取参数 <a class="header-anchor" href="#_2-listener-获取参数" aria-label="Permalink to “2.Listener 获取参数”">​</a></h4><p>Listener 通过 RPC 向参数服务器发送参数查找请求，请求中包含要查找的参数名。</p><h4 id="_3-ros-master-向-listener-发送参数值" tabindex="-1">3.ROS Master 向 Listener 发送参数值 <a class="header-anchor" href="#_3-ros-master-向-listener-发送参数值" aria-label="Permalink to “3.ROS Master 向 Listener 发送参数值”">​</a></h4><p>ROS Master 根据步骤2请求提供的参数名查找参数值，并将查询结果通过 RPC 发送给 Listener。</p><hr><p>参数可使用数据类型:</p><ul><li>32-bit integers</li><li>booleans</li><li>strings</li><li>doubles</li><li>iso8601 dates</li><li>lists</li><li>base64-encoded binary data</li><li>字典</li></ul><blockquote><p>注意:参数服务器不是为高性能而设计的，因此最好用于存储静态的非二进制的简单数据</p></blockquote>',16)])])}const b=a(s,[["render",n]]);export{m as __pageData,b as default};
