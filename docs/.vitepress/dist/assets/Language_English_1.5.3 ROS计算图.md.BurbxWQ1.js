import{_ as r,c as e,o as t,af as _,at as s}from"./chunks/framework.BYZYS_oT.js";const g=JSON.parse('{"title":"1.5.3 ROS计算图","description":"","frontmatter":{},"headers":[],"relativePath":"Language/English/1.5.3 ROS计算图.md","filePath":"Language/English/1.5.3 ROS计算图.md"}'),n={name:"Language/English/1.5.3 ROS计算图.md"};function i(o,a,p,h,l,c){return t(),e("div",null,[...a[0]||(a[0]=[_('<h1 id="_1-5-3-ros计算图" tabindex="-1">1.5.3 ROS计算图 <a class="header-anchor" href="#_1-5-3-ros计算图" aria-label="Permalink to “1.5.3 ROS计算图”">​</a></h1><h4 id="_1-计算图简介" tabindex="-1">1.计算图简介 <a class="header-anchor" href="#_1-计算图简介" aria-label="Permalink to “1.计算图简介”">​</a></h4><p>前面介绍的是ROS文件结构，是磁盘上 ROS 程序的存储结构，是静态的，而 ros 程序运行之后，不同的节点之间是错综复杂的，ROS 中提供了一个实用的工具:rqt_graph。</p><p>rqt_graph能够创建一个显示当前系统运行情况的动态图形。ROS 分布式系统中不同进程需要进行数据交互，计算图可以以点对点的网络形式表现数据交互过程。rqt_graph是rqt程序包中的一部分。</p><h4 id="_2-计算图演示" tabindex="-1">2.计算图演示 <a class="header-anchor" href="#_2-计算图演示" aria-label="Permalink to “2.计算图演示”">​</a></h4><p>接下来以 ROS 内置的小乌龟案例来演示计算图</p><p>首先，按照前面所示，运行案例</p><p>然后，启动新终端，键入: rqt_graph 或 rosrun rqt_graph rqt_graph，可以看到类似下图的网络拓扑图，该图可以显示不同节点之间的关系。<img src="'+s+'" alt="img"></p>',8)])])}const S=r(n,[["render",i]]);export{g as __pageData,S as default};
